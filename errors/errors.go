package errors

import (
	"bytes"
	"fmt"
	"io"
	"strings"
)

type Error struct {
	Msg            string
	Labels         *Labels
	Err            error
	Stack          *Stack
	RawStackTraces []*Stack // This field is generated by New/Errorf/Wrap at the first place, and copied by Wrap afterwards
}

func (e *Error) Error() string {
	return formatError(e)
}

var formatError = func(e *Error) string {
	if e.Err == nil {
		return e.Msg
	}
	return e.Msg + " || " + e.Err.Error()
}

var formatStackTrace = func (i int, err *Error) string {
	return fmt.Sprintf("%d. @%s (%s: %d) -> %s %v \n", i, err.Stack.FuncName, getFileNameFromPath(err.Stack.File), err.Stack.Line, err.Msg, err.Labels)
}

var formatRawStackTrace = func (i int, s *Stack) string {
	return fmt.Sprintf("%d. @%s (%s: %d) \n", i, s.FuncName, s.File, s.Line)
}

func getFileNameFromPath(s string) string {
	fragments := strings.Split(s, "/")
	return fragments[len(fragments)-1]
}

// StackTraceString は登録スタック基づいた範囲でトレース情報を出力
func (e *Error) StackTraceString() string {
	buff := bytes.Buffer{}
	errors := ListErrorChain(e)
	for i, err := range errors {
		buff.WriteString(formatStackTrace(i, err))
		if i == (len(errors) - 1) && err.Err != nil {
			buff.WriteString(fmt.Sprintf("Cause: %s \n", err.Err.Error()))
		}
	}
	return buff.String()
}

func (e *Error) PrintStackTrace(w io.Writer) {
	fmt.Fprint(w, e.StackTraceString())
}

// RawStackTraceString は発生地点から全てのスタックを走査したトレース情報を出力
func (e *Error) RawStackTraceString() string {
	buff := bytes.Buffer{}
	for i, s := range e.RawStackTraces {
		buff.WriteString(formatRawStackTrace(i, s))
	}
	return buff.String()
}

func (e *Error) PrintRawStackTrace(w io.Writer) {
	fmt.Fprint(w, e.RawStackTraceString())
}

func (e *Error) Cause() error  {
	chain := ListErrorChain(e)
	if len := len(chain); len > 0 {
		return chain[len -1].Err
	}
	return nil
}

func ListErrorChain(topOfStack error) []*Error {
	err, ok := topOfStack.(*Error)
	if !ok {
		return []*Error{}
	}
	list := []*Error{err}
	child, ok := err.Err.(*Error)
	if !ok {
		return list
	}
	return append(list, ListErrorChain(child)...)
}

func New(labels *Labels, msg string) *Error {
	stack, _ := NewStack(2)
	return &Error{
		Msg:            msg,
		Labels:         labels,
		Err:            nil,
		Stack:          stack,
		RawStackTraces: NewStackTrace(3),
	}
}

func Errorf(labels *Labels, format string, args ...interface{}) *Error {
	msg := fmt.Sprintf(format, args...)
	stack, _ := NewStack(2)
	return &Error{
		Msg:            msg,
		Labels:         labels,
		Err:            nil,
		Stack:          stack,
		RawStackTraces: NewStackTrace(3),
	}
}

func Wrap(cause error, labels *Labels, msg string) *Error {
	stack, _ := NewStack(2)
	error, ok := cause.(*Error)
	wrap := &Error{
		Msg:            msg,
		Labels:         labels,
		Stack:          stack,
	}
	if !ok {
		wrap.Err = cause
		wrap.RawStackTraces = NewStackTrace(3)
	} else {
		wrap.Err = error
		wrap.RawStackTraces = error.RawStackTraces
	}
	return wrap
}

func Wrapf(cause error, labels *Labels, format string, args ...interface{}) *Error {
	stack, _ := NewStack(2)
	error, ok := cause.(*Error)
	wrap := &Error{
		Msg:            fmt.Sprintf(format, args...),
		Labels:         labels,
		Stack:          stack,
	}
	if !ok {
		wrap.Err = cause
		wrap.RawStackTraces = NewStackTrace(3)
	} else {
		wrap.Err = error
		wrap.RawStackTraces = error.RawStackTraces
	}
	return wrap
}
